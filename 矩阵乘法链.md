git repo:https://github.com/kid-od/Algorithmn



# 矩阵乘法链



## 1.算法思想

1. **明确问题目标**：多个矩阵相乘的方式不同会导致计算量差异巨大，需要找到最佳加括号方式，使总的标量乘法次数最少。

2. **分析最优子结构**：若想最优计算矩阵链 Aᵢ…Aⱼ，必然存在一个断点 k，把它拆成两个子链 Aᵢ…Aₖ 和 Aₖ₊₁…Aⱼ，且这两个子问题也必须分别最优。这种“大问题依赖小问题最优解”的性质正适合动态规划。

3. **定义状态变量**：用 m[i] [j] 表示从矩阵 Aᵢ 乘到 Aⱼ 的最少乘法次数，用 s[i] [j] 记录实现最优代价时的断点位置，为最终恢复括号结构准备数据。

4. **构建状态转移方程**：当 i = j 时，不需要乘法，因此 m[i] [i] = 0；当 i < j 时，遍历 i ≤ k < j，比较不同断点 k 的代价：

   m[i] [j] = m[i] [k] + m[k+1] [j] + p[i−1] × p[k] × p[j]

   

   **p 是存放矩阵链中所有矩阵维度的数组**，长度为 n+1。

   第 i 个矩阵的形状由 p[i-1] 和 p[i] 决定

   

   取最小值作为最优解，并记录对应断点。

5. **动态规划求解顺序**：采用“由短到长”的区间 DP 思想，先求链长为 1 的子问题，再求链长为 2、3…n 的问题，保证每次求解时所需子问题已完成。

6. **输出最优结果与括号方案**：m[1] [n] 即为整个矩阵链的最小计算代价，再依托 s[i] [j] 表递归还原最优括号化序列。

   

   

   **初始化**

          j→ 1    2    3    4    5    6
   i↓    -------------------------------
   1     |  0
   2     |       0
   3     |            0
   4     |                 0
   5     |                      0
   6     |                           0

   

   计算代价

   | **分割方式** |       **计算代价公式**        | **结果**                     |
   | ------------ | :---------------------------: | ---------------------------- |
   | (A₁)(A₂A₃)   | m[1] [1] + m[2] [3] + 30×35×5 | 0 + 2625 + 5250 = **7875**   |
   | (A₁A₂)(A₃)   | m[1] [2] + m[3] [3] + 30×15×5 | 15750 + 0 + 2250 = **18000** |



**m 表（最少计算次数）**

	     1       2       3       4       5        6
1 |   0             15750           7875       9375   ...     15125
2 |        0          2625          4375           ...
3 |               0      750           ...
4 |                       0     ...
5 |                             0
6 |                                  0



**s 表（最优分割点）

| **i\j** | **1** | **2** | **3** | **4** | **5** | **6** |
| ------- | ----- | ----- | ----- | ----- | ----- | ----- |
| 1       | -     | 1     | 1     | 3     | …     | 3     |
| 2       | -     | 2     | 2     | …     |       |       |
| 3       | -     | 3     | …     |       |       |       |
| 4       | -     | 4     |       |       |       |       |
| 5       | -     | 5     |       |       |       |       |
| 6       | -     |       |       |       |       |       |



**回溯过程**

Print(1,6)
 ↓ k=3
( Print(1,3)    Print(4,6) )
         ↓                ↓
     k=1                  k=5
( A1  (A2 A3) )     ( (A4 A5) A6 )





## 2.代码

```c
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

/// 分配 long long 类型的二维数组，大小为 (n+1)×(n+1)
long long **alloc_ll2d(int n) {
    long long **a = (long long**)malloc((n+1) * sizeof(long long*));
    for (int i = 0; i <= n; ++i)
        a[i] = (long long*)malloc((n+1) * sizeof(long long));
    return a;
}

/// 分配 int 类型的二维数组，大小为 (n+1)×(n+1)
int **alloc_i2d(int n) {
    int **a = (int**)malloc((n+1) * sizeof(int*));
    for (int i = 0; i <= n; ++i)
        a[i] = (int*)malloc((n+1) * sizeof(int));
    return a;
}

/// 释放 long long 类型二维数组
void free_ll2d(long long **a, int n) {
    for (int i = 0; i <= n; ++i) free(a[i]);
    free(a);
}

/// 释放 int 类型二维数组
void free_i2d(int **a, int n) {
    for (int i = 0; i <= n; ++i) free(a[i]);
    free(a);
}

/// 递归打印最优矩阵链的括号结构
void print_paren(int **s, int i, int j) {
    if (i == j) {        // 只有一个矩阵，不需要括号
        printf("A%d", i);
        return;
    }
    printf("(");
    print_paren(s, i, s[i][j]);       // 打印左子链的括号
    print_paren(s, s[i][j] + 1, j);   // 打印右子链的括号
    printf(")");
}

/// 求解单个测试样例：p 为维度数组，n 为矩阵数量
void solve_case(int p[], int n) {
    long long **m = alloc_ll2d(n);   // m[i][j] 存放最少乘法次数
    int **s = alloc_i2d(n);          // s[i][j] 存放最优分割点

    // 初始化：矩阵自身不需要乘法，因此对角线元素为 0
    for (int i = 1; i <= n; ++i)
        m[i][i] = 0;

    // L 表示链长，从 2 开始递增（区间 DP 的长度枚举）
    for (int L = 2; L <= n; ++L) {
        for (int i = 1; i <= n - L + 1; ++i) {
            int j = i + L - 1;       // 区间右端点 j
            m[i][j] = LLONG_MAX / 4; // 初始化为极大值，避免溢出

            // 尝试所有可能分割点 k，求最小代价
            for (int k = i; k < j; ++k) {
                long long cost = m[i][k] + m[k+1][j] + 
                                 1LL * p[i-1] * p[k] * p[j]; // 代价计算公式
                if (cost < m[i][j]) {
                    m[i][j] = cost;  // 更新最优值
                    s[i][j] = k;     // 记录分割点
                }
            }
        }
    }

    // 输出结果
    printf("最少标量乘法次数: %lld\n", m[1][n]);
    printf("最优括号化: ");
    print_paren(s, 1, n);
    printf("\n\n");

    // 释放动态内存
    free_ll2d(m, n);
    free_i2d(s, n);
}

int main() {
    printf("========= 测试用例运行开始 =========\n\n");

    // 测试用例 1（经典教材案例）
    {
        int p[] = {30, 35, 15, 5, 10, 20, 25};
        int n = 6;
        printf("【用例 1】输入: 6\n维度: 30 35 15 5 10 20 25\n");
        solve_case(p, n);
    }

    // 测试用例 2
    {
        int p[] = {5, 10, 3, 12, 5, 50, 6};
        int n = 6;
        printf("【用例 2】输入: 6\n维度: 5 10 3 12 5 50 6\n");
        solve_case(p, n);
    }

    // 测试用例 3
    {
        int p[] = {10, 100, 5, 50};
        int n = 3;
        printf("【用例 3】输入: 3\n维度: 10 100 5 50\n");
        solve_case(p, n);
    }

    // 测试用例 4
    {
        int p[] = {40, 20, 30, 10, 30};
        int n = 4;
        printf("【用例 4】输入: 4\n维度: 40 20 30 10 30\n");
        solve_case(p, n);
    }

    printf("========= 所有测试运行结束 =========\n");
    return 0;
}
```





## 3.用例结果

```tex
========= 测试用例运行开始 =========

【用例 1】输入: 6
维度: 30 35 15 5 10 20 25
最少标量乘法次数: 15125
最优括号化: ((A1(A2A3))((A4A5)A6))

【用例 2】输入: 6
维度: 5 10 3 12 5 50 6
最少标量乘法次数: 2010
最优括号化: ((A1A2)((A3A4)(A5A6)))

【用例 3】输入: 3
维度: 10 100 5 50
最少标量乘法次数: 7500
最优括号化: ((A1A2)A3)

【用例 4】输入: 4
维度: 40 20 30 10 30
最少标量乘法次数: 26000
最优括号化: ((A1(A2A3))A4)

========= 所有测试运行结束 =========

[Execution complete with exit code 0]
```





