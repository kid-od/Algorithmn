**git repo:https://github.com/kid-od/Algorithmn*



# 矩阵乘法链

## 1.算法思想

1. **明确问题目标**：多个矩阵相乘的方式不同会导致计算量差异巨大，需要找到最佳加括号方式，使总的标量乘法次数最少。

2. **分析最优子结构**：若想最优计算矩阵链 Aᵢ…Aⱼ，必然存在一个断点 k，把它拆成两个子链 Aᵢ…Aₖ 和 Aₖ₊₁…Aⱼ，且这两个子问题也必须分别最优。这种“大问题依赖小问题最优解”的性质正适合动态规划。

3. **定义状态变量**：用 m[i][j] 表示从矩阵 Aᵢ 乘到 Aⱼ 的最少乘法次数，用 s[i][j] 记录实现最优代价时的断点位置，为最终恢复括号结构准备数据。

4. **构建状态转移方程**：当 i = j 时，不需要乘法，因此 m[i][i] = 0；当 i < j 时，遍历 i ≤ k < j，比较不同断点 k 的代价：

   m[i][j] = m[i][k] + m[k+1][j] + p[i−1] × p[k] × p[j]

   取最小值作为最优解，并记录对应断点。

5. **动态规划求解顺序**：采用“由短到长”的区间 DP 思想，先求链长为 1 的子问题，再求链长为 2、3…n 的问题，保证每次求解时所需子问题已完成。

6. **输出最优结果与括号方案**：m[1][n] 即为整个矩阵链的最小计算代价，再依托 s[i][j] 表递归还原最优括号化序列。



## 2.代码

```c
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

long long **alloc_ll2d(int n) {
    long long **a = (long long**)malloc((n+1) * sizeof(long long*));
    for (int i = 0; i <= n; ++i)
        a[i] = (long long*)malloc((n+1) * sizeof(long long));
    return a;
}

int **alloc_i2d(int n) {
    int **a = (int**)malloc((n+1) * sizeof(int*));
    for (int i = 0; i <= n; ++i)
        a[i] = (int*)malloc((n+1) * sizeof(int));
    return a;
}

void free_ll2d(long long **a, int n) {
    for (int i = 0; i <= n; ++i) free(a[i]);
    free(a);
}

void free_i2d(int **a, int n) {
    for (int i = 0; i <= n; ++i) free(a[i]);
    free(a);
}

void print_paren(int **s, int i, int j) {
    if (i == j) {
        printf("A%d", i);
        return;
    }
    printf("(");
    print_paren(s, i, s[i][j]);
    print_paren(s, s[i][j] + 1, j);
    printf(")");
}

void solve_case(int p[], int n) {
    long long **m = alloc_ll2d(n);
    int **s = alloc_i2d(n);

    for (int i = 1; i <= n; ++i)
        m[i][i] = 0;

    for (int L = 2; L <= n; ++L) {
        for (int i = 1; i <= n - L + 1; ++i) {
            int j = i + L - 1;
            m[i][j] = LLONG_MAX / 4;
            for (int k = i; k < j; ++k) {
                long long cost = m[i][k] + m[k+1][j] + 1LL * p[i-1] * p[k] * p[j];
                if (cost < m[i][j]) {
                    m[i][j] = cost;
                    s[i][j] = k;
                }
            }
        }
    }

    printf("最少标量乘法次数: %lld\n", m[1][n]);
    printf("最优括号化: ");
    print_paren(s, 1, n);
    printf("\n\n");

    free_ll2d(m, n);
    free_i2d(s, n);
}

int main() {
    printf("========= 测试用例运行开始 =========\n\n");

    // 测试用例 1
    {
        int p[] = {30, 35, 15, 5, 10, 20, 25};
        int n = 6;
        printf("【用例 1】输入: 6\n维度: 30 35 15 5 10 20 25\n");
        solve_case(p, n);
    }

    // 测试用例 2
    {
        int p[] = {5, 10, 3, 12, 5, 50, 6};
        int n = 6;
        printf("【用例 2】输入: 6\n维度: 5 10 3 12 5 50 6\n");
        solve_case(p, n);
    }

    // 测试用例 3
    {
        int p[] = {10, 100, 5, 50};
        int n = 3;
        printf("【用例 3】输入: 3\n维度: 10 100 5 50\n");
        solve_case(p, n);
    }

    // 测试用例 4
    {
        int p[] = {40, 20, 30, 10, 30};
        int n = 4;
        printf("【用例 4】输入: 4\n维度: 40 20 30 10 30\n");
        solve_case(p, n);
    }

    printf("========= 所有测试运行结束 =========\n");
    return 0;
}


```





## 3.用例结果

```tex
========= 测试用例运行开始 =========

【用例 1】输入: 6
维度: 30 35 15 5 10 20 25
最少标量乘法次数: 15125
最优括号化: ((A1(A2A3))((A4A5)A6))

【用例 2】输入: 6
维度: 5 10 3 12 5 50 6
最少标量乘法次数: 2010
最优括号化: ((A1A2)((A3A4)(A5A6)))

【用例 3】输入: 3
维度: 10 100 5 50
最少标量乘法次数: 7500
最优括号化: ((A1A2)A3)

【用例 4】输入: 4
维度: 40 20 30 10 30
最少标量乘法次数: 26000
最优括号化: ((A1(A2A3))A4)

========= 所有测试运行结束 =========

[Execution complete with exit code 0]
```





