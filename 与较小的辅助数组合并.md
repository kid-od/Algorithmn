# 1.算法思路

先复制左半部分到辅助数组temp中，然后用三个指针进行合并，当temp中元素用完时，后半部份已经在a[n..2n-1]原地，剩下都有序。

保证了只使用长度为n的辅助数组。

# 2.代码

```c
#include <stdio.h>
#include <stdlib.h>

/**
 * 合并两个长度为 n 的有序子数组：
 * a[0..n-1] 与 a[n..2n-1]
 * 只使用长度为 n 的辅助数组 temp
 */
void merge_with_half_buffer(int* a, int n) {
    int* temp = (int*)malloc(sizeof(int) * n);
    if (!temp) {
        printf("内存分配失败\n");
        return;
    }

    // 复制左半部分到 temp
    for (int i = 0; i < n; i++) temp[i] = a[i];

    int i = 0;     // temp 指针
    int j = n;     // 右半部分起点
    int k = 0;     // 写回位置

    while (i < n && j < 2 * n) {
        if (temp[i] <= a[j])
            a[k++] = temp[i++];
        else
            a[k++] = a[j++];
    }

    // 若 temp 还有剩余元素
    while (i < n) {
        a[k++] = temp[i++];
    }

    free(temp);
}

int main() {
    // 示例数组：前半部分和后半部分分别已排序
    int a[] = {1, 4, 6, 2, 3, 7};
    int n = 3;  // 每个子数组长度

    printf("合并前: ");
    for (int i = 0; i < 2 * n; i++) printf("%d ", a[i]);
    printf("\n");

    merge_with_half_buffer(a, n);

    printf("合并后: ");
    for (int i = 0; i < 2 * n; i++) printf("%d ", a[i]);
    printf("\n");

    return 0;
}
```



# 3.运行结果

![截屏2025-10-14 19.45.58](/Users/entropy/Desktop/截屏2025-10-14 19.45.58.png)