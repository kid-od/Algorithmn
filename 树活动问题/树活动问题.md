# 1.

![question_1](https://raw.githubusercontent.com/kid-od/Algorithmn/main/树活动问题/1.png)

```c
#include <stdio.h>

// 结构体表示一个活动
typedef struct {
    int start;   // 开始时间
    int end;     // 结束时间
} Activity;

// 按结束时间排序（冒泡排序，仅为便于展示，可换成 qsort）
void sortByEndTime(Activity a[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - 1 - i; j++) {
            if (a[j].end > a[j + 1].end) {
                Activity temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
            }
        }
    }
}

// 活动选择函数，返回选择的最大不冲突活动数
int activitySelection(Activity a[], int n) {
    sortByEndTime(a, n);  // 先根据结束时间排序

    printf("选择的活动为：\n");
    // 第一个活动一定选
    int count = 1;
    printf("(%d, %d)\n", a[0].start, a[0].end);

    int lastEnd = a[0].end;

    // 遍历剩下的活动
    for (int i = 1; i < n; i++) {
        if (a[i].start >= lastEnd) {
            printf("(%d, %d)\n", a[i].start, a[i].end);
            count++;
            lastEnd = a[i].end;
        }
    }

    return count;
}

int main() {
    // 测试例子
    Activity arr[] = {
        {1, 4},
        {3, 5},
        {0, 6},
        {5, 7},
        {3, 9},
        {5, 9},
        {6, 10},
        {8, 11},
        {8, 12},
        {2, 14},
        {12, 16}
    };

    int n = sizeof(arr) / sizeof(arr[0]);

    int result = activitySelection(arr, n);
    printf("最多可选择的活动数量为：%d\n", result);

    return 0;
}
```





# 2.

![question_1](https://raw.githubusercontent.com/kid-od/Algorithmn/main/树活动问题/2.png)

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int start;
    int end;
    int weight;
} Activity;

// 按结束时间排序
int cmp(const void *a, const void *b) {
    Activity *x = (Activity*)a;
    Activity *y = (Activity*)b;
    return x->end - y->end;
}

// 使用二分查找求 p[j]
// p[j] = 在 j 之前结束，且不与 j 冲突的最后一个活动下标
int findP(Activity a[], int j) {
    int low = 0, high = j - 1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (a[mid].end <= a[j].start) {
            if (a[mid + 1].end <= a[j].start)
                low = mid + 1;
            else
                return mid;
        } else {
            high = mid - 1;
        }
    }
    return -1;
}

int main() {
    // 测试样例
    Activity arr[] = {
        {1, 3, 5},
        {2, 5, 6},
        {4, 6, 5},
        {6, 7, 4},
        {5, 8, 11},
        {7, 9, 2}
    };

    int n = sizeof(arr) / sizeof(arr[0]);

    // 第一步：按结束时间排序 O(n log n)
    qsort(arr, n, sizeof(Activity), cmp);

    // 第二步：预处理 p[j]  O(n log n)
    int p[n];
    for (int j = 0; j < n; j++)
        p[j] = findP(arr, j);

    // 第三步：动态规划求最大权值 O(n)
    int D[n + 1];
    int Rec[n + 1];
    D[0] = 0;

    for (int j = 1; j <= n; j++) {
        int include = arr[j - 1].weight + (p[j - 1] != -1 ? D[p[j - 1] + 1] : 0);
        int exclude = D[j - 1];

        if (include > exclude) {
            D[j] = include;
            Rec[j] = 1;
        } else {
            D[j] = exclude;
            Rec[j] = 0;
        }
    }

    // 第四步：回溯输出选择方案 O(n)
    printf("选择的活动集合为:\n");
    int k = n;
    while (k > 0) {
        if (Rec[k] == 1) {
            printf(" 活动: (start=%d, end=%d, weight=%d)\n",
                   arr[k - 1].start, arr[k - 1].end, arr[k - 1].weight);
            k = p[k - 1] + 1;
        } else {
            k = k - 1;
        }
    }

    printf("\n最大权值 = %d\n", D[n]);

    return 0;
}
```





# 3.针对带树活动选择问题，阐述你的理解。

带权活动选择问题引入“权值”后，核心思想从“选最多活动”转变为“选收益最高的活动集合”，其本质是一种带有互斥约束的优化决策。解决问题的关键在于：先按结束时间排序，再为每个活动找到不与之冲突的最近前驱活动，通过动态规划比较“选”与“不选”的收益，从而构建最优解。当遇到带有树状结构的活动选择场景时，问题会进一步复杂化，因为选择某个活动不再是独立决策，而可能与父节点或子节点存在依赖或互斥关系，收益不再是简单相加。这类问题需要在时间约束之外同时处理层级或结构约束，使其更接近带依赖选择的优化问题，而非单纯的区间调度。
