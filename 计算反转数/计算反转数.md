# 1.算法思路

左右两个子数组已经各自有序，当 left[i] > right[j] 时，因为左数组有序，左边 i 之后的所有元素都大于 right[j]，所以产生了 (mid - i + 1) 个反转。

总时间复杂度为O(nlogn)

# 2.代码实现（c语言）

```c
#include <stdio.h>
#include <stdlib.h>

long long merge_and_count(int arr[], int temp[], int left, int mid, int right) {
    int i = left;      // 左子数组起点
    int j = mid + 1;   // 右子数组起点
    int k = left;      // 临时数组下标
    long long inv_count = 0;

    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
            inv_count += (mid - i + 1); // 左边剩余的都比 arr[j] 大
        }
    }

    // 复制剩余部分
    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];

    // 写回原数组
    for (i = left; i <= right; i++) arr[i] = temp[i];

    return inv_count;
}

long long merge_sort_and_count(int arr[], int temp[], int left, int right) {
    long long inv_count = 0;
    if (left < right) {
        int mid = (left + right) / 2;
        inv_count += merge_sort_and_count(arr, temp, left, mid);
        inv_count += merge_sort_and_count(arr, temp, mid + 1, right);
        inv_count += merge_and_count(arr, temp, left, mid, right);
    }
    return inv_count;
}

long long count_inversions(int arr[], int n) {
    int *temp = (int *)malloc(n * sizeof(int));
    long long inv_count = merge_sort_and_count(arr, temp, 0, n - 1);
    free(temp);
    return inv_count;
}

int main() {
    int arr1[] = {2, 4, 1, 3, 5};
    int n1 = sizeof(arr1) / sizeof(arr1[0]);
    printf("反转数: %lld\n", count_inversions(arr1, n1));

    int arr2[] = {5, 4, 3, 2, 1};
    int n2 = sizeof(arr2) / sizeof(arr2[0]);
    printf("反转数: %lld\n", count_inversions(arr2, n2));

    int arr3[] = {1, 2, 3, 4, 5};
    int n3 = sizeof(arr3) / sizeof(arr3[0]);
    printf("反转数: %lld\n", count_inversions(arr3, n3));

    int arr4[] = {8, 4, 2, 1};
    int n4 = sizeof(arr4) / sizeof(arr4[0]);
    printf("反转数: %lld\n", count_inversions(arr4, n4));

    return 0;
}
```



# 3.运行结果

![截屏2025-10-14 09.26.09](/Users/entropy/Desktop/截屏2025-10-14 09.26.09.png)

